type: edu
files:
- name: src/Channel.java
  visible: true
  placeholders:
  - offset: 104
    length: 15
    placeholder_text: /*TODO_TAKE_1*/
    initial_state:
      length: 15
      offset: 104
    initialized_from_dependency: false
    possible_answer: synchronized
    selected: false
    status: Unchecked
  - offset: 140
    length: 15
    placeholder_text: /*TODO_TAKE_2*/
    initial_state:
      length: 15
      offset: 140
    initialized_from_dependency: false
    possible_answer: |-
      if (isChannelEmpty) {
            callWaitMethod();
          }
    selected: false
    status: Unchecked
  - offset: 160
    length: 28
    placeholder_text: /*TODO_TAKE_3*/ return null;
    initial_state:
      length: 28
      offset: 160
    initialized_from_dependency: false
    possible_answer: |-
      isChannelEmpty = true;
          notifyListenersAboutChangesInChannel();
          return message;
    selected: false
    status: Unchecked
  - offset: 203
    length: 14
    placeholder_text: /*TODO_PUT_1*/
    initial_state:
      length: 14
      offset: 203
    initialized_from_dependency: false
    possible_answer: synchronized
    selected: false
    status: Unchecked
  - offset: 249
    length: 14
    placeholder_text: /*TODO_PUT_2*/
    initial_state:
      length: 14
      offset: 249
    initialized_from_dependency: false
    possible_answer: |-
      if (!isChannelEmpty) {
            callWaitMethod();
          }
    selected: false
    status: Unchecked
  - offset: 268
    length: 14
    placeholder_text: /*TODO_PUT_3*/
    initial_state:
      length: 14
      offset: 268
    initialized_from_dependency: false
    possible_answer: |-
      this.message = message;
          isChannelEmpty = false;
          notifyListenersAboutChangesInChannel();
    selected: false
    status: Unchecked
  text: |-
    public class Channel {
      protected String message;
      protected boolean isChannelEmpty = true;

      public /*TODO_TAKE_1*/ String take() {
        /*TODO_TAKE_2*/
        /*TODO_TAKE_3*/ return null;
      }

      public /*TODO_PUT_1*/ void put(String message) {
        /*TODO_PUT_2*/
        /*TODO_PUT_3*/
      }

      protected void notifyListenersAboutChangesInChannel() {
        notifyAll();
      }

      protected void callWaitMethod() {
        try {
          wait();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  learner_created: false
- name: test/TestChannel.java
  visible: false
  text: |-
    import org.junit.Assert;
    import org.junit.Test;

    import java.lang.reflect.Method;
    import java.lang.reflect.Modifier;

    public class TestChannel {

      @Test(expected = WaitMethodCalledException.class)
      public void whenChannelIsEmptyAndWeTryToTake_waitMethodShouldBeCalled() {
        FakeChannel channel = new FakeChannel();
        channel.isChannelEmpty = true;

        channel.take();
      }

      @Test
      public void whenChannelIsNotEmptyAndWeTryToTake_channelShouldGetEmpty() {
        FakeChannel channel = new FakeChannel();
        channel.message = "msg";
        channel.isChannelEmpty = false;

        String msgFromChannel = channel.take();
        Assert.assertTrue("message received is not the one from the channel", msgFromChannel.equals(channel.message));
        Assert.assertTrue("after take() call, the channel should be empty", channel.isChannelEmpty);
        Assert.assertTrue("notifyAll() method not called if a change was made in the Channel", channel.notifyListenersMethodCalled);
      }

      @Test
      public void takeMethodShouldBeSynchronized() throws NoSuchMethodException {
        Method method = Channel.class.getMethod("take");
        Assert.assertTrue("take() is not synchronized", Modifier.isSynchronized(method.getModifiers()));
      }

      @Test(expected = WaitMethodCalledException.class)
      public void whenChannelIsFullAndWeTryToPut_waitMethodShouldBeCalled() {
        FakeChannel channel = new FakeChannel();
        channel.isChannelEmpty = false;

        channel.put("msg");
      }

      @Test
      public void whenChannelIsEmptyAndWeTryToPut_channelShouldGetFull() {
        FakeChannel channel = new FakeChannel();
        channel.isChannelEmpty = true;

        String msgToPut = "msg";
        channel.put(msgToPut);
        Assert.assertTrue("message not received correctly in the channel", msgToPut.equals(channel.message));
        Assert.assertFalse("after put(message) call, the channel should be full", channel.isChannelEmpty);
        Assert.assertTrue("notifyAll() method not called if a change was made in the Channel", channel.notifyListenersMethodCalled);
      }

      @Test
      public void putMethodShouldBeSynchronized() throws NoSuchMethodException {
        Method method = Channel.class.getMethod("put", String.class);
        Assert.assertTrue("put(message) is not synchronized", Modifier.isSynchronized(method.getModifiers()));
      }
    }
  learner_created: false
- name: test/WaitMethodCalledException.java
  visible: false
  text: |-
    public class WaitMethodCalledException extends RuntimeException {
    }
  learner_created: false
- name: test/FakeChannel.java
  visible: false
  text: |+
    public class FakeChannel extends Channel {
      protected boolean waitMethodCalled = false;
      protected boolean notifyListenersMethodCalled = false;

      protected void callWaitMethod() {
        this.waitMethodCalled = true;
        throw new WaitMethodCalledException();
      }

      protected void notifyListenersAboutChangesInChannel() {
        this.notifyListenersMethodCalled = true;
      }
    }


  learner_created: false
status: Unchecked
record: -1
